package com.tbse.algebro;

import java.util.ArrayList;

import org.anddev.andengine.entity.IEntity;
import org.anddev.andengine.entity.modifier.MoveModifier;
import org.anddev.andengine.entity.scene.Scene;
import org.anddev.andengine.input.touch.TouchEvent;
import org.anddev.andengine.util.modifier.IModifier;
import org.anddev.andengine.util.modifier.IModifier.IModifierListener;

import android.util.Log;
import android.view.VelocityTracker;

public class Expression {

	public boolean isConstant;
	public int value;
	public ArrayList<Symbol> symbols;
	public VelocityTracker velocityTracker;
	Vector2 touchToCorner;
	private MainGameActivity main;
	private int touchDownSymbolCode;
	private int padding; // for small phone, moves icon out of under thumb

	private enum NEXT_IN_TOUCH_CYCLE {
		TOUCH_DOWN, TOUCH_UP
	};

	NEXT_IN_TOUCH_CYCLE nextInTouchCycle;

	public ArrayList<Symbol> getExpressionSymbols() {
		return this.symbols;
	}

	public boolean isRemovable() {
		if (getExpressionSymbols() != null) {
			if (getExpressionSymbols().size() >= 1) {
				return getExpressionSymbols().get(0).isRemovable();
			}
		}
		return false;
	}

	public Expression() {
		this.symbols = new ArrayList<Symbol>(0);
		this.touchToCorner = new Vector2(0, 0);
		this.nextInTouchCycle = NEXT_IN_TOUCH_CYCLE.TOUCH_DOWN;
		this.padding = -50; // touch padding
	}

	public int getValue() {
		return this.value;
	}

	public MainGameActivity getMain() {
		if (this.main == null) {
			Log.e("ab", "trying to get main but it's null");
		}
		return this.main;
	}

	public void setMain(MainGameActivity m) {
		this.main = m;
	}

	public Scene getScene() {
		return getMain().getScene();
	}

	public boolean isInASpecialArea(float x, float y) {
		for (SpecialArea a : getMain().getSpecialAreas()) {
			if (a.contains(x, y)) {
				return true;
			}
		}
		return false;
	}

	public boolean isInASpecialArea(TouchEvent e) {
		return isInASpecialArea(e.getX(), e.getY());
	}

	public float getSpeed() {
		getVelocityTracker().computeCurrentVelocity(1000, 10000f); // pixels per second
		return new Vector2(getVelocityTracker().getXVelocity(),
				getVelocityTracker().getYVelocity()).len();

	}

	public boolean onAreaTouched(final TouchEvent pSceneTouchEvent,
			final float pTouchAreaLocalX, final float pTouchAreaLocalY,
			Symbol symbol) {

		if (pSceneTouchEvent.getAction() == TouchEvent.ACTION_DOWN) {

			if (this.nextInTouchCycle != NEXT_IN_TOUCH_CYCLE.TOUCH_DOWN) {
				Log.e("ab", "out of cycle");
				return false;
			} else {
				this.nextInTouchCycle = NEXT_IN_TOUCH_CYCLE.TOUCH_UP;
			}

			getNewVelocityTracker();

			getVelocityTracker().addMovement(pSceneTouchEvent.getMotionEvent());

			this.touchDownSymbolCode = symbol.symbolCode;

			if (isInASpecialArea(pSceneTouchEvent)) {
				// Log.d("ab", "is in a special area");
				symbol.setIsRemovable(true);

				touchToCorner = new Vector2(symbol.getX()
						- pSceneTouchEvent.getX(), symbol.getY()
						- pSceneTouchEvent.getY());
				// Log.d("ab", "done making the touchToCorner vector now1: "
				// + touchToCorner.toString());

				// The copy stays behind
				Symbol symbolCopy = new Symbol(symbol.getX(), symbol.getY(),
						symbol.pTiledTextureRegion, symbol.getMain(),
						symbol.symbolCode, false);
				symbolCopy.parentExpression = new Expression();
				symbolCopy.parentExpression.setMain(getMain());
				// Log.d("ab",
				// "running addSymbol with the new copy: "+symbolCopy.parentExpression.toString());
				symbolCopy.parentExpression.addSymbol(0, symbolCopy);
				// Log.d("ab",
				// "expression touchdown returning: "+symbolCopy.parentExpression.toString());
				return true;

			} else { // symbol touched on the board, should already be in an
						// expression, use getX() and getY() for it
				touchToCorner = new Vector2(getX() - pSceneTouchEvent.getX(),
						getY() - pSceneTouchEvent.getY());

				// if the screen is small, push it up and left so it won't
				// be under the finger.
			}

		} else

		if (pSceneTouchEvent.getAction() == TouchEvent.ACTION_MOVE) {

			if (this.nextInTouchCycle != NEXT_IN_TOUCH_CYCLE.TOUCH_UP) {
				Log.e("ab", "move is out of cycle");
				return false;
			}

			getNewVelocityTracker();
			getVelocityTracker().addMovement(pSceneTouchEvent.getMotionEvent());
			getVelocityTracker().computeCurrentVelocity(1000, 10000f);
			Log.d("ab", "xvel: " + getVelocityTracker().getXVelocity()
					+ ",   yvel: " + getVelocityTracker().getYVelocity());

			float factor = 50.0f / (1 + (float) Math
					.exp(-(getSpeed() - 150) / 2));
			if (factor < 0.1)
				factor = 0.0f;

			Log.d(" ab", "s[" + getSpeed() + "]\t f[" + factor + "]");

			if (getExpressionSymbols().size() == 0) {
				Log.e("ab", "trying to move an expression with no symbols");
			}

			// MoveModifier mm = new MoveModifier(1, getX(),
			// pSceneTouchEvent.getX() + touchToCorner.x + vel.x, getY(),
			// pSceneTouchEvent.getY() + touchToCorner.y + vel.y,
			// MainGameActivity.EASEFUNCTIONS[0]);
			//
			// registerEntityModifiers(mm);

			// Log.d("ab", "setPosition(" + pSceneTouchEvent.getX() + " + "
			// + touchToCorner.x + " / "
			// + pSceneTouchEvent.getY() + " + " + touchToCorner.y
			// );
			setPosition(pSceneTouchEvent.getX() + touchToCorner.x + padding,
					pSceneTouchEvent.getY() + touchToCorner.y + padding);

		} else

		if (pSceneTouchEvent.getAction() == TouchEvent.ACTION_UP) {

			if (this.nextInTouchCycle != NEXT_IN_TOUCH_CYCLE.TOUCH_UP) {
				Log.d("ab", "up is out of cycle");
				return false;
			} else {
				this.nextInTouchCycle = NEXT_IN_TOUCH_CYCLE.TOUCH_DOWN;
			}

			if (isInASpecialArea(pSceneTouchEvent)) {
				if (symbol.symbolCode == this.touchDownSymbolCode) {

					// Is in a special area and user has clicked on a tile,
					// put it out in the middle.

					Symbol symbolCopy = new Symbol(
							getMain().getCameraWidth() >> 1, getMain()
									.getCameraHeight() >> 1,
							symbol.pTiledTextureRegion, symbol.getMain(),
							symbol.symbolCode, true);
					symbolCopy.parentExpression = new Expression();
					symbolCopy.parentExpression.setMain(getMain());
					// Log.d("ab",
					// "running addSymbol with the new copy: "+symbolCopy.parentExpression.toString());
					symbolCopy.parentExpression.addSymbol(0, symbolCopy);

				}

				destroySelf();

			} else {
				// got a symbol already on the screen

				getNewVelocityTracker();
				getVelocityTracker().addMovement(
						pSceneTouchEvent.getMotionEvent());

				if (symbol.isRemovable()) {
					getVelocityTracker().computeCurrentVelocity(1000, 10000f);
					if (getSpeed() > 150) {
						Log.d("ab", "adding "
								+ (0.1f * getVelocityTracker().getXVelocity())
								+ " to x");
						Log.d("ab", "adding "
								+ (0.1f * getVelocityTracker().getYVelocity())
								+ " to y");

						MoveModifier mm = new MoveModifier(1, getX(), getX()
								+ 0.1f * getVelocityTracker().getXVelocity(),
								getY(), getY() + 0.1f
										* getVelocityTracker().getYVelocity(),
								MainGameActivity.EASEFUNCTIONS[0]);

						mm.addModifierListener(new IModifierListener<IEntity>() {

							@Override
							public void onModifierStarted(
									IModifier<IEntity> arg0, IEntity arg1) {
								// TODO Auto-generated method stub

							}

							@Override
							public void onModifierFinished(
									IModifier<IEntity> arg0, IEntity arg1) {
								// TODO Auto-generated method stub

								if (isInASpecialArea(getX(), getY())) {
									destroySelf();
								} else {
									main.checkForCollisions();
								}

							}
						});
						registerEntityModifiers(mm);
					}
				}
				velocityTracker.recycle();

			}
			this.touchDownSymbolCode = -100;
		}

		return true;
	}

	private VelocityTracker getVelocityTracker() {
		return this.velocityTracker;
	}

	private void registerEntityModifiers(MoveModifier m) {
		for (Symbol s : getExpressionSymbols()) {
			s.registerEntityModifier(m);
		}
	}

	public void setValue(int value) {
		this.value = value;
	}

	public float getX() {
		float total = 0f;
		if (getExpressionSymbols().size() == 0) {
			Log.e("ab",
					"there are no symbols in the expression, can't give getX()");
			return 1;
		}
		for (Symbol s : getExpressionSymbols()) {
			total += s.getX();
		}
		return total / getExpressionSymbols().size();
	}

	public float getY() {
		float total = 0f;
		if (getExpressionSymbols().size() == 0) {
			Log.e("ab",
					"there are no symbols in the expression, can't give getY()");
			return 1;
		}

		for (Symbol s : getExpressionSymbols()) {
			total += s.getY();
		}
		return total / getExpressionSymbols().size();
	}

	public void setPosition(final float expressionCornerX,
			final float expressionCornerY) {
		// Log.d("ab", "about to try to set pos for symbols");
		for (final Symbol s : getExpressionSymbols()) {
			// Log.d("ab", "setting pos for a symbol at " + expressionCornerX
			// + ", " + expressionCornerY);
			s.setPosition(expressionCornerX, expressionCornerY);
		}
	}

	public void destroySelf() {
		for (final Symbol s : getExpressionSymbols()) {
			getScene().postRunnable(new Runnable() {
				@Override
				public void run() {
					// TODO Auto-generated method stub
					s.destroySelf();
				}

			});
		}
	}

	public VelocityTracker getNewVelocityTracker() {
		while (getVelocityTracker() == null) {
			// Log.d("ab", "trying again to get a velocity tracker");
			setVelocityTracker(VelocityTracker.obtain());
		}
		return getVelocityTracker();
	}

	public void setVelocityTracker(VelocityTracker vt) {
		this.velocityTracker = vt;
	}

	public Expression addSymbol(int index, Symbol symbol) {
		if (!getExpressionSymbols().contains(symbol)) {
			getExpressionSymbols().add(symbol);
		}
		return this;
	}

	public void attachChildren() {
		for (Symbol s : getExpressionSymbols()) {
			if (s.hasParent() == false) {
				getScene().attachChild(s);
			} else {
				Log.d("ab", "attachChildren, has a parent already");
			}
		}
	}

	public void registerTouchAreas() {
		for (Symbol s : getExpressionSymbols()) {
			getScene().registerTouchArea(s);
		}
	}

}
